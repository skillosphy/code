max 

procedure max(a1, a2... an : integers)
max = a1

for i = 2 to n
if ai > max then max = ai
return max

procedure linear search(x: integer, a1, a2.... an :integers)
i = 1
while (i <=n and x =/ ai)
    i = i + 1


if i <=n then location = 1
else location = 0

return location

procedure binary search(x: integer, a1.... an: integers)
i = 1
j = n
while i < j
m = lower bound of i+j/2
if x>am then i = m + 1
else j = m

if x=ai then location = i
else location =0

return location

procedure bubblesort(a1.... an)
for i = 1 to n -1
    for j = 1 to n - i
        if aj>aj+1 then interchange


procedure insertion sort(an)

for j = 2 to n
i = 1

while aj>ai
i = i +1

m = aj
for k =0 to j-i-1

aj-k = aj-k-1

ai = m;

procedure binary search (x: integer, a1, a2.... an: integers)
i = 1
j = n

while ( i < j)
m = lower bound of i + j /2

if x > am then i = m +1
else j = m

if x = ai then location = i
else location = 0

return location


linear search

i = 1
while (i<=n and x not equal to ai)
i = i+1

if i <=n then location = i
else location 0


return location


 bubble sort 

 for i = 1 to n-1
    for j = 1 to n-if
    if aj > aj+1 then interchange aj and aj+1


procedure insertion sort

for j = 2 to n
i = 1
while aj > ai
    i = i + 1
m = aj

for k = 0 to j - i - 1
aj-k = aj-k--1
ai = m 



insertion sort 

for j = 2 to n
i = 1 

while (aj > ai)
    i = i + 1
m = aj

for k = 0 to j - i - 1
aj-k = aj-k-1
ai =m
